name: CI-CD

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch: {}

env:
  AWS_REGION: ap-south-1
  EKS_CLUSTER_NAME: devops-portfolio-eks
  ECR_REPOSITORY: devops-portfolio-app
  PYTHON_VERSION: "3.11"

  # ---- Kubernetes deploy targets (adjust if your YAML uses different names) ----
  K8S_NAMESPACE: demo
  DEPLOYMENT_NAME: devops-portfolio-app
  CONTAINER_NAME: devops-portfolio-app

jobs:
  pipeline:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ------------------ Python + Tests ------------------
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pytest

      - name: Unit tests (pytest)
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pytest -q

      - name: Integration tests (docker compose)
        run: |
          docker compose up -d --build
          chmod +x tests/integration/smoke.sh
          bash tests/integration/smoke.sh
          docker compose down

      # ------------------ AWS Auth (THIS decides which IAM user is used) ------------------
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # DEBUG: show identity used by the workflow
      - name: DEBUG - AWS identity (who am I)
        run: |
          aws --version
          aws sts get-caller-identity
          aws iam get-user || true

      # Pre-check: can this identity describe the cluster?
      - name: DEBUG - EKS DescribeCluster
        run: |
          aws eks describe-cluster \
            --name "${{ env.EKS_CLUSTER_NAME }}" \
            --region "${{ env.AWS_REGION }}" \
            --query "cluster.name" \
            --output text

      # ------------------ ECR Build & Push ------------------
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE_URI="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV

          docker build -t "${IMAGE_URI}" .
          docker tag "${IMAGE_URI}" "${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }}:latest"

          docker push "${IMAGE_URI}"
          docker push "${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }}:latest"

      # ------------------ kubectl + EKS ------------------
      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig \
            --name "${{ env.EKS_CLUSTER_NAME }}" \
            --region "${{ env.AWS_REGION }}"

      # ------------------ Deploy (FIXED: no k8s/ path) ------------------
      - name: Deploy to EKS
        run: |
          kubectl version --client=true
          kubectl cluster-info

          echo "Applying namespaces/"
          kubectl apply -f namespaces/

          echo "Applying database/"
          kubectl apply -f database/

          echo "Applying app/"
          kubectl apply -f app/

          echo "Set app image to the one built in this workflow:"
          echo "  Namespace: ${{ env.K8S_NAMESPACE }}"
          echo "  Deployment: ${{ env.DEPLOYMENT_NAME }}"
          echo "  Container: ${{ env.CONTAINER_NAME }}"
          echo "  Image: ${IMAGE_URI}"

          kubectl -n "${{ env.K8S_NAMESPACE }}" set image deployment/"${{ env.DEPLOYMENT_NAME }}" \
            "${{ env.CONTAINER_NAME }}"="${IMAGE_URI}" --record || true

          kubectl -n "${{ env.K8S_NAMESPACE }}" rollout status deployment/"${{ env.DEPLOYMENT_NAME }}" --timeout=300s || true

          kubectl get pods -A
          kubectl get svc -A
